---
title: "Untitled"
author: "Angelica Norato"
date: "`r Sys.Date()`"
output: html_document
---


```{r setup, include=FALSE}

library(readxl)
library(readxl)
library(dplyr)

library(tidyverse)
library(lubridate)
library(ggplot2)

```

# Graficas de series de tiempo

```{r}
ventas = read_excel("/Users/angeliknorato/Documents/Javeriana /Series de Tiempo/Series_de_tiempo/Ventas_t.xlsx")
View(ventas)
```

```{r}
# Asegurarse de que la columna 'semana' tiene formato fecha
ventas$Fecha <- as.Date(ventas$Fecha, format = "%Y-%m-%d")
```

```{r}
# Verificar el formato de la columna
str(ventas$Fecha)
```


Hemos detectado numeros negativos en la base de datos, estos son valores de devoluciones. Sin embargo, como nuestro objetivo es hacer modelacion de las ventas, convertiremos estos valores a cero.

```{r}
# Convertir todos los valores negativos a ceros
ventas[ventas < 0] = 0
```



Debido a que nuestra nuestra base de datos contiene 80 items, decidimos hacer una agrupacion por clase de item, obteniendo las siguientes categorias =
 - AVR (Auto regulador de Voltaje).
 - Data_Center (Accesorio para equipos).
 - Line UPS (Baja capacidad, uso hogar).
 - Online UPS (Alta capacidad, uso empresarial).
 - Solar (Inversores Solares). 
 - Storage_Battery (Almacenadores de Energia).
 - Surge (Multitomas). 
 - Accesorios. 


# Agrupar por categorias 

```{r}

AVR = ventas%>% select(`Fecha`, `Item 10`, `Item 26`, `Item 30`, `Item 39`, `Item 45`, 
                       `Item 49`, `Item 55`, `Item 62`, `Item 66`, `Item 79`)

Data_Center = ventas%>% select(`Fecha`, `Item 53`)


Line_UPS = ventas%>% select(`Fecha`, `Item 1`, `item 2`, `Item 3`, `Item 6`, `Item 9`, 
                            `Item 15`, `Item 17`, `Item 22`, `Item 34`, `Item 48`, 
                            `Item 51`, `Item 59`, `Item 63`, `Item 68`, `Item 70`,
                            `Item 71`, `Item 75`)


Online_UPS = ventas%>% select(`Fecha`, `Item 4`, `Item 5`, `Item 7`, `Item 8`, `Item 12`, 
                            `Item 13`, `Item 14`, `Item 16`, `Item 19`, `Item 20`, 
                            `Item 21`, `Item 23`, `Item 25`, `Item 27`, `Item 28`,
                            `Item 29`, `Item 31`, `Item 32`, `Item 33`, `Item 38`, `Item 41`, 
                            `Item 43`, `Item 44`, `Item 46`, `Item 50`, `Item 56`, `Item 57`, 
                           `Item 58`, `Item 60`, `Item 65`, `Item 72`, `Item 76`, `Item 77`, 
                           `Item 80`)


Solar = ventas%>% select(`Fecha`, `Item 36`, `Item 52`, `Item 69`, `Item 74`)


Storage_Battery = ventas%>% select(`Fecha`, `Item 11`, `Item 18`, `Item 24`, `Item 35`, 
                                   `Item 37`, `Item 40`, `Item 64`, `Item 67`, `Item 78`)


Surge = ventas%>% select(`Fecha`, `Item 47`, `Item 54`, `Item 61`)


Accessories = ventas%>% select(`Fecha`, `Item 42`, `Item 73`)

```


Hallamos el valor total por categoria : 

```{r}

# Crear una columna del total de items por catgoria

AVR = AVR%>% mutate(Total = rowSums(select(.,`Item 10`, `Item 26`, `Item 30`, `Item 39`,
                                           `Item 45`, `Item 49`,`Item 55`, `Item 62`, 
                                           `Item 66`, `Item 79`), na.rm = TRUE))

Data_Center = Data_Center%>% mutate(Total = rowSums(select(.,`Item 53`), na.rm = TRUE))


Line_UPS = Line_UPS%>% mutate(Total = rowSums(select(.,`Item 1`, `item 2`, `Item 3`, 
                                                     `Item 6`, `Item 9`, `Item 15`, `Item 17`,
                                                     `Item 22`, `Item 34`, `Item 48`,
                                                     `Item 51`, `Item 59`, `Item 63`, 
                                                     `Item 68`, `Item 70`,
                                                     `Item 71`, `Item 75`), na.rm = TRUE))


Online_UPS = Online_UPS%>% mutate(Total = rowSums(select(.,`Item 4`, `Item 5`, `Item 7`, 
                                                         `Item 8`, `Item 12`, `Item 13`, 
                                                         `Item 14`, `Item 16`, `Item 19`,
                                                         `Item 20`, `Item 21`, `Item 23`,
                                                         `Item 25`, `Item 27`, `Item 28`,
                                                         `Item 29`, `Item 31`, `Item 32`,
                                                         `Item 33`, `Item 38`, `Item 41`, 
                                                         `Item 43`, `Item 44`, `Item 46`,
                                                         `Item 50`, `Item 56`, `Item 57`, 
                                                         `Item 58`, `Item 60`, `Item 65`,
                                                         `Item 72`, `Item 76`, `Item 77`, 
                                                         `Item 80`), na.rm = TRUE))


Solar = Solar%>% mutate(Total = rowSums(select(.,`Item 36`, `Item 52`, `Item 69`, `Item 74`),
                                        na.rm = TRUE))


Storage_Battery = Storage_Battery%>% mutate(Total = rowSums(select(.,`Item 11`, `Item 18`,
                                                                   `Item 24`, `Item 35`, 
                                                                   `Item 37`, `Item 40`, 
                                                                   `Item 64`, `Item 67`, 
                                                                   `Item 78`), na.rm = TRUE))


Surge = Surge%>% mutate(Total = rowSums(select(., `Item 47`, `Item 54`, `Item 61`), 
                                        na.rm = TRUE))


Accessories = Accessories%>% mutate(Total = rowSums(select(., `Item 42`, `Item 73`), 
                                                  na.rm = TRUE))
```



Después de un análisis de los datos, decidimos enfocarnos en cuatro categorías: 
AVR, Line UPS, Online UPS y Battery Storage, que en total suman 70 ítems. 
No se han considerado las categorías de Data Center, Solar, Surge y Accesorios, 
ya que hemos observado una gran cantidad de ceros en estas, lo que sugiere que 
podemos incluir estos ítems para venta solo por pedido especial y no es necesario 
mantenerlos en inventario.



## Analisis por categoria 


# AVR (Auto regulador de Voltaje)

```{r}
# Convertir a serie de tiempo
AVR_ts <- ts(AVR$Total, start = c(2021, 2), frequency = 52)

# Verificar la clase del objeto
class(AVR_ts)
```
## Plot 

```{r}
# plot
plot(AVR_ts, main= "AVR ", ylab= "Ventas", xlab= "Semana")
```
 

##  Media móvil (4 períodos)

```{r}
media_movil_AVR = stats::filter(AVR_ts, rep(1/4, 4), sides = 2)
print(media_movil_AVR)

plot(media_movil_AVR, main= "AVR Media Movil ", ylab= "Ventas", xlab= "Semana")
```


## Lag plot 

```{r}
# lag plot grafica de resagos 
lag.plot(AVR_ts, 20, main = "AVR", do.lines = FALSE)
```





# Line UPS (Baja capacidad, uso hogar)

```{r}
# Convertir a serie de tiempo
Line_UPS_ts <- ts(Line_UPS$Total, start = c(2021, 2), frequency = 52)

class(Line_UPS_ts) 
```

## Plot

```{r}
# plot
plot(Line_UPS_ts, main= "Line UPS ", ylab= "Ventas", xlab= "Semana")
```

## Media móvil (4 períodos)

```{r}
media_movil_Line_UPS = stats::filter(Line_UPS_ts, rep(1/4, 4), sides = 2)
print(media_movil_Line_UPS)

plot(media_movil_Line_UPS, main= "Line UPS Media Movil ", ylab= "Ventas", xlab= "Semana")
```

## Lag Plot

```{r}
# lag plot grafica de resagos 
lag.plot(Line_UPS_ts, 20, main = "Line UPS", do.lines = FALSE)
```

Conclusion....



# Online UPS (Alta capacidad, uso empresarial)

```{r}
# Convertir a serie de tiempo
Online_UPS_ts <- ts(Online_UPS$Total, start = c(2021, 2), frequency = 52)

class(Online_UPS_ts) 
```

## Plot

```{r}
# plot
plot(Online_UPS_ts, main= "Online UPS ", ylab= "Ventas", xlab= "Semana")
```
## Media móvil (4 períodos)

```{r}
media_movil_Online_UPS = stats::filter(Online_UPS_ts, rep(1/4, 4), sides = 2)
print(media_movil_Online_UPS)

plot(media_movil_Online_UPS, main= "Online UPS Media Movil ", ylab= "Ventas", xlab= "Semana")
```

## lag plot grafica de resagos 

```{r}
# lag plot grafica de resagos 
lag.plot(Online_UPS_ts, 20, main = "Online UPS", do.lines = FALSE)
```

Conclusiones....


# Storage_Battery (Almacenadores de Energia)


```{r}
# Convertir a serie de tiempo
Storage_Battery_ts <- ts(Storage_Battery$Total, start = c(2021, 2), frequency = 52)

class(Storage_Battery_ts) 
```

# Plot

```{r}
plot(Storage_Battery_ts, main= "Storage Battery ", ylab= "Ventas", xlab= "Semana")
```

## Media móvil (4 períodos)

```{r}
media_movil_Storage_Battery = stats::filter(Storage_Battery_ts, rep(1/4, 4), sides = 2)
print(media_movil_Storage_Battery)

plot(media_movil_Storage_Battery, main= "Online UPS Media Movil ", ylab= "Ventas", xlab= "Semana")
```


# lag plot grafica de rezagos 

```{r}
lag.plot(Storage_Battery_ts, 20, main = "Storage Battery",  do.lines = FALSE)
```


# Entrega 3

```{r}
library(tseries)
```


### 1. Verificamos estacionalidad:

### AVR


```{r}
   # Perform the Augmented Dickey-Fuller test
   adf_AVR <- adf.test(AVR_ts)

   # Print the results
   print(adf_AVR)
```

La base de datos AVR presenta estacionalidad. 



### Line UPS

```{r}
  # Perform the Augmented Dickey-Fuller test
   adf_Line_UPS <- adf.test(Line_UPS_ts)

   # Print the results
   print(adf_Line_UPS)
```

La base de datos Line_ UPS presenta estacionalidad. 


### Online UPS

```{r}
  # Perform the Augmented Dickey-Fuller test
   adf_Online_UPS <- adf.test(Online_UPS_ts)

   # Print the results
   print(adf_Online_UPS)
```

La base de datos Online_ UPS presenta estacionalidad. 


### Storage Battery

```{r}
  # Perform the Augmented Dickey-Fuller test
   adf_Storage_Battery <- adf.test(Storage_Battery_ts)

   # Print the results
   print(adf_Storage_Battery)
```

La base de datos Online_ UPS presenta estacionalidad. 

## Conclusión: 

Podemos observar que en las 4 categorias el test Dickey-Fuller, arroja un p-value menor a 0.05, lo que nos confirma la estacionalidad de los datos. 




## ANALISIS DE LA CATEGORIA AVR

### Funciones acf (Funcion de Autocorrelacion) y pacf ( Funcion de Autocorrelacion Parcial)

```{r}
library(forecast)
```

```{r}
# Graficar ACF y PACF
par(mfrow=c(1,2))  
Acf(AVR_ts, main='Función de Autocorrelación (ACF)')
Pacf(AVR_ts, main='Función de Autocorrelación Parcial (PACF)')
```


El hecho de que el lag 42 sea significativo indica que hay un patrón estacional que se repite cada 42 semanas. Dado que hay aproximadamente 52 semanas en un año, esto podría sugerir una estacionalidad que se manifiesta en un ciclo de aproximadamente 10 meses.

Dado que identificamos un patrón estacional, sería apropiado considerar un modelo SARIMA (Seasonal AutoRegressive Integrated Moving Average) para capturar tanto la tendencia como la estacionalidad. En este caso, el componente estacional podría tener un período de 42

La falta de otras correlaciones significativas en lags más cortos sugiere que las ventas no dependen mucho de las semanas anteriores en el corto plazo. 


### Descomposicion aditiva: 


```{r}
library(stats)
```


```{r}
# Descomposición aditiva
descomposicion_aditiva_AVR <- decompose(AVR_ts)

# Graficar los componentes
plot(descomposicion_aditiva_AVR)
```



Componente observada (observed): Esta es la serie de tiempo original. Muestra el comportamiento general de los datos a lo largo del tiempo, incluyendo las fluctuaciones, tendencias y patrones estacionales.

Componente de tendencia (trend): Aquí se muestra la tendencia a largo plazo de la serie de tiempo. Representa la dirección general de la serie (si está aumentando, disminuyendo o permaneciendo relativamente constante). En la gráfica, puedes ver que hay una caída en la tendencia alrededor de 2022, seguida de una recuperación en 2023.

Componente estacional (seasonal): Este componente captura los patrones repetitivos o cíclicos que se presentan en intervalos regulares, como los que podrían ocurrir debido a fenómenos estacionales (por ejemplo, aumentos en ventas por estaciones del año). En la gráfica, puedes ver que hay picos y valles que se repiten en intervalos regulares.

Componente aleatorio o residual (random): Representa la parte no explicada por la tendencia o los patrones estacionales, es decir, las fluctuaciones aleatorias o ruido. Estas variaciones no siguen un patrón predecible y pueden deberse a eventos externos o factores impredecibles.

¿Qué significa que sea una descomposición aditiva?
En una descomposición aditiva, los valores observados de la serie de tiempo se descomponen como la suma de los tres componentes: tendencia, estacionalidad y componente aleatorio. Es decir:

Observado
=
Tendencia
+
Estacionalidad
+
Aleatorio
Observado=Tendencia+Estacionalidad+Aleatorio

Relación con la transformación de raíz cuadrada
Aunque no mencionas explícitamente la serie de tiempo transformada en la gráfica, una transformación de raíz cuadrada se utiliza frecuentemente para estabilizar la varianza de la serie y reducir el impacto de valores extremos. Esto podría haber sido aplicado antes de la descomposición, haciendo que las fluctuaciones de la serie original (observada) sean menos extremas. La transformación de raíz cuadrada puede hacer que la serie parezca más lineal, facilitando la identificación de patrones subyacentes como tendencias o estacionalidad.

En resumen, esta gráfica te muestra cómo los diferentes componentes de una serie de tiempo (tendencia, estacionalidad y ruido) contribuyen al comportamiento general de la serie, lo cual es útil para análisis más detallados y predicciones futuras.



## Descomposicion multiplicativa:


```{r}
# Descomposición multiplicativa
descomposicion_multiplicativa_AVR <- decompose(AVR_ts, type = "multiplicative")

# Graficar los componentes
plot(descomposicion_multiplicativa_AVR)
```


A medida que el tiempo avanza, la varianza tiende a disminuir. Al analizar los residuos, también se observa que la varianza no se mantiene constante a lo largo del tiempo, lo que sugiere que se trata de un modelo multiplicativo.



## Convertir en aditivo: 

Debido a la gran cantidad de ceros no se puede aplicar logaritmos para transformar el modelo de multiplicativo a aditivo. 

Dado que nuestros datos contienen muchos ceros utilizaremos la transformacion y'=log(y+c) con c = 1, para garantizar la no existencia de ceros 

o usemos raiz cuadrada 

```{r}
AVR_ts_sqrt <- sqrt(AVR_ts)

# Configuración para gráficos
par(mfrow=c(1,2))

# Gráfico de ACF
acf(AVR_ts_sqrt, main='Función de Autocorrelación (ACF)')

# Gráfico de PACF
pacf(AVR_ts_sqrt, main='Función de Autocorrelación Parcial (PACF)')
```

```{r}
# Descomposición aditiva
descomposicion_aditiva_AVR_sqrt <- decompose(AVR_ts_sqrt)

# Graficar los componentes
plot(descomposicion_aditiva_AVR_sqrt)
```





```{r}
# Suavizamiento exponencial
suavizado_doble <- HoltWinters(AVR_ts)

# Visualizar el suavizamiento
plot(suavizado_doble)

# Descomposición de la serie de tiempo
descomposicion <- stl(AVR_ts, s.window = "periodic")
plot(descomposicion)

```



## ANALISIS DE LA CATEGORIA LINE UPS

### Funciones acf (Funcion de Autocorrelacion) y pacf ( Funcion de Autocorrelacion Parcial)

```{r}
# Graficar ACF y PACF
par(mfrow=c(1,2))  
Acf(Line_UPS_ts, main='Función de Autocorrelación (ACF)')
Pacf(Line_UPS_ts, main='Función de Autocorrelación Parcial (PACF)')
```


El hecho de que el lag 35 sea significativo indica que hay un patrón estacional que se repite cada 35 semanas,  lo cual es bastante inusual, ya que muchas series de tiempo suelen tener patrones estacionales más cortos (como semanal, mensual o trimestral).

Dado que identificamos un patrón estacional, sería apropiado considerar un modelo SARIMA (Seasonal AutoRegressive Integrated Moving Average) para capturar tanto la tendencia como la estacionalidad. En este caso, el componente estacional podría tener un período de 35

```{r}
# Descomposición aditiva
descomposicion_aditiva_Line_UPS <- decompose(Line_UPS_ts)

# Graficar los componentes
plot(descomposicion_aditiva_Line_UPS)
```

```{r}
# Descomposición multiplicativa
descomposicion_multiplicativa_Line_UPS <- decompose(Line_UPS_ts, type = "multiplicative")

# Graficar los componentes
plot(descomposicion_multiplicativa_Line_UPS)
```



## ANALISIS DE LA CATEGORIA ONLINE UPS

### Funciones acf (Funcion de Autocorrelacion) y pacf ( Funcion de Autocorrelacion Parcial)

```{r}
# Graficar ACF y PACF
par(mfrow=c(1,2))  
Acf(Online_UPS_ts, main='Función de Autocorrelación (ACF)')
Pacf(Online_UPS_ts, main='Función de Autocorrelación Parcial (PACF)')
```
El hecho de que el lag 35 sea significativo indica que hay un patrón estacional que se repite cada 35 semanas y 47 semanas,  lo cual es bastante inusual, ya que muchas series de tiempo suelen tener patrones estacionales más cortos (como semanal, mensual o trimestral).

Dado que identificamos un patrón estacional, sería apropiado considerar un modelo SARIMA (Seasonal AutoRegressive Integrated Moving Average) para capturar tanto la tendencia como la estacionalidad. En este caso, el componente estacional podría tener un período de 37 y 47

```{r}
# Descomposición aditiva
descomposicion_aditiva_Online_UPS <- decompose(Online_UPS_ts)

# Graficar los componentes
plot(descomposicion_aditiva_Online_UPS)
```


```{r}
# Descomposición multiplicativa
descomposicion_multiplicativa_Online_UPS <- decompose(Online_UPS_ts, type = "multiplicative")

# Graficar los componentes
plot(descomposicion_multiplicativa_Online_UPS)
```



## ANALISIS DE LA CATEGORIA STORAGE BATTERY

### Funciones acf (Funcion de Autocorrelacion) y pacf ( Funcion de Autocorrelacion Parcial)


```{r}
# Graficar ACF y PACF
par(mfrow=c(1,2))  
Acf(Storage_Battery_ts, main='Función de Autocorrelación (ACF)')
Pacf(Storage_Battery_ts, main='Función de Autocorrelación Parcial (PACF)')
```

```{r}
# Descomposición aditiva
descomposicion_aditiva_Storage_Battery <- decompose(Storage_Battery_ts)

# Graficar los componentes
plot(descomposicion_aditiva_Storage_Battery)
```

```{r}
# Descomposición multiplicativa
descomposicion_multiplicativa_Online_UPS <- decompose(Online_UPS_ts, type = "multiplicative")

# Graficar los componentes
plot(descomposicion_multiplicativa_Online_UPS)
```



# Entrega 4 
# Predicción con Holt Winters


```{r setup1, include=FALSE}
library(forecast)
```


### AVR

```{r}
# Suavizamiento exponencial
HW_AVR <- HoltWinters(AVR_ts)

# Visualizar el suavizamiento
plot(HW_AVR)

```

### Prediccion AVR

```{r}
NextYear_AVR = forecast(HW_AVR, h=12)

NextYear_AVR
```

```{r}
accuracy(NextYear_AVR)
```

```{r}
plot(NextYear_AVR)
```




### Line UPS


```{r}
# Suavizamiento exponencial
HW_Line_UPS <- HoltWinters(Line_UPS_ts)

# Visualizar el suavizamiento
plot(HW_Line_UPS)

```

### Prediccion Line UPS
```{r}
NextYear_Line_UPS = forecast(HW_Line_UPS, h=12)

NextYear_Line_UPS
```


```{r}
accuracy(NextYear_Line_UPS)
```

```{r}
plot(NextYear_Line_UPS)
```



### Online UPS

```{r}
# Suavizamiento exponencial
HW_Online_UPS <- HoltWinters(Online_UPS_ts)

# Visualizar el suavizamiento
plot(HW_Online_UPS)
```


### Prediccion Online UPS
```{r}
NextYear_Online_UPS = forecast(HW_Online_UPS, h=12)

NextYear_Online_UPS
```

```{r}
accuracy(NextYear_Online_UPS)
```

```{r}
plot(NextYear_Online_UPS)
```


### Storage Battery


```{r}
# Suavizamiento exponencial
HW_Storage_Battery <- HoltWinters(Storage_Battery_ts)

# Visualizar el suavizamiento
plot(HW_Storage_Battery)
```


### Prediccion Storage Battery
```{r}
NextYear_Storage_Battery = forecast(HW_Storage_Battery, h=12)

NextYear_Storage_Battery
```


```{r}
accuracy(NextYear_Storage_Battery)
```

```{r}
plot(NextYear_Storage_Battery)
```


Conclusion: 
Nuestros valores de MAPE (Mean Absolute Percentage Error) son extremadamente altos y sugiriendo que el modelo de pronóstico tiene un desempeño muy deficiente. 

La MAPE se expresa como un porcentaje y mide el error absoluto medio en relación con los valores reales. lo que nos indica que que errores de pronóstico son mucho mayores que los valores reales. 

Si el valor real es cero en algún punto, el cálculo del MAPE se vuelve problemático, ya que implica dividir por cero. Por esta razon el modelo de Holt-Winters no es adecuado para el pronostico de ventas de nuestra base de datos. 


